# -*- coding: utf-8 -*-
"""Merging1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H597SJ5Jegr99bWRUNy2wfjsBJ4SMLiH
"""

import pandas as pd
import numpy as np
import re

# --- 1. Data Loading (Reading from CSV Files) ---

try:
    # NOTE: Using the file paths provided by the user
    tmdb_df = pd.read_csv('tmdb_movie_data_2009-2025.csv')
    boxoffice_df = pd.read_csv('boxoffice_2009-2025.csv')

except FileNotFoundError as e:
    # Updated error message to reflect the new file names
    print(f"Error: One of the input files was not found. Missing file: {e}")

# Rename the Box Office movie title column for easier merging
boxoffice_df = boxoffice_df.rename(columns={'Release': 'title'})

print("--- Initial TMDB Data Sample ---")
print(tmdb_df.head(2))
print("\n--- Initial Box Office Data Sample ---")
print(boxoffice_df.head(2))

# --- 2. Feature Engineering: Pre-Release Features ---

# A. Studio, Genre, and Year Extraction
def extract_studio_genre_and_year_features(df):
    """
    Extracts two studio names, two genres, and the release year from existing columns.
    Renames the first genre to 'primary_genre' and sets the default release year to 2009.
    """
    # 1. Studio Extraction
    studio_series = df['production_studios'].fillna('')
    df['studio_1'] = studio_series.apply(lambda x: x.split('|')[0] if x else 'Unknown')

    def get_second_studio(studios_str):
        parts = studios_str.split('|')
        return parts[1] if len(parts) > 1 else 'None'

    df['studio_2'] = studio_series.apply(get_second_studio)

    # 2. Genre Extraction
    genre_series = df['genres'].fillna('')
    # Extracts the first genre and names it 'primary_genre'
    df['primary_genre'] = genre_series.apply(lambda x: x.split('|')[0] if x else 'None')

    def get_second_genre(genres_str):
        parts = genres_str.split('|')
        return parts[1] if len(parts) > 1 else 'None'

    df['genre2'] = genre_series.apply(get_second_genre)

    # 3. Release Year Extraction
    # Assuming 'release_date' is in 'YYYY-MM-DD' format
    df['release_year'] = pd.to_datetime(df['release_date'], errors='coerce').dt.year.fillna(2009).astype(int)

    return df

# B. Brand Name and Actor Refinement
def refine_names_and_branding(df):
    """
    Creates the 'brand_name' feature (General for non-sequels) and renames actor columns.
    """
    # 1. Brand Name Refinement
    def get_brand_name(row):
        title = str(row['title'])
        # If it's a sequel, extract the core brand
        if row['is_sequel'] == 1:
            match = re.split(r':| - ', title, 1)
            if len(match) > 1:
                return match[0].strip()
            # General cleaning for sequel numbering/naming
            core_name = re.sub(r'\s(2|II|III|IV|V|Reloaded|Revolutions|Begins|Returns|Rises|Part\s\d|\d)$', '', title, flags=re.IGNORECASE).strip()
            return core_name if core_name != title else title
        else:
            # If it's NOT a sequel, use the suggested 'General' tag
            return 'General'

    df['brand_name'] = df.apply(get_brand_name, axis=1)

    # 2. Actor Renaming
    # Rename the existing lead actor features
    df = df.rename(columns={
        'lead_actor_name': 'lead_actor1',
        'lead_actor_popularity': 'lead_actor1_popularity'
    })

    # NOTE: Features for the second lead actor are intentionally omitted as requested.

    return df

# Apply the new feature engineering steps
tmdb_df = extract_studio_genre_and_year_features(tmdb_df)
tmdb_df = refine_names_and_branding(tmdb_df)

# --- 2.5 Feature Engineering: Distributor Extraction and Merge ---
# Extract the first unique Distributor name from the Box Office data
distributor_map = boxoffice_df[['title', 'Distributor']].drop_duplicates(subset=['title'], keep='first')

# Merge the Distributor feature into the TMDB features DataFrame
tmdb_df = pd.merge(tmdb_df, distributor_map, on='title', how='left')

# --- 3. Data Cleaning & Target Variable Calculation ---

def clean_currency_to_numeric(series):
    """
    Removes non-numeric characters ($, commas) and converts the series to float.
    """
    cleaned_series = series.astype(str).str.replace('$', '', regex=False).str.replace(',', '', regex=False)
    return pd.to_numeric(cleaned_series, errors='coerce')

boxoffice_df['Daily_Gross_Numeric'] = clean_currency_to_numeric(boxoffice_df['Daily'])
boxoffice_df['Days'] = pd.to_numeric(boxoffice_df['Days'], errors='coerce')


# Calculate the target variable: First Week Income (Days 1-7)
first_week_data = boxoffice_df[
    (boxoffice_df['Days'] >= 1) & (boxoffice_df['Days'] <= 7)
].copy()

first_week_income_df = first_week_data.groupby('title')['Daily_Gross_Numeric'].sum().reset_index()
first_week_income_df = first_week_income_df.rename(columns={'Daily_Gross_Numeric': 'First_Week_Income'})

# --- 4. Data Merging: Combine Features (TMDB) with Target (Box Office) ---
final_dataset = pd.merge(
    tmdb_df,
    first_week_income_df,
    on='title',
    how='left'
)

"""## **Final list of pre-release features and the target variable:**


**release_year:** The year the movie was released, useful for capturing temporal trends.

**budget:** The total cost to produce the film (in USD), a key indicator of production scale.

**runtime:** The length of the movie in minutes.

**is_sequel:** A binary flag (1/0) indicating if the movie is part of an existing franchise.


**director_name:** The name of the primary director.

**director_popularity:** The director's pre-release popularity score (based on TMDB data).

**lead_actor1:** The name of the main actor/actress.

**lead_actor1_popularity:** The main actor's pre-release popularity score (based on TMDB data).

**lead_actor2:** The name of the second lead actor/actress.


**genre1:** The primary genre of the movie.

**genre2:** The secondary genre of the movie.

**studio_1:** The primary production company involved.

**studio_2:** The secondary production company (co-producer/partner).


**brand_name:** The core franchise name (e.g., "Batman"). Set to 'General' if not a sequel.

**mpaa_rating:** The movie's US parental guidance rating (e.g., G, PG, PG-13, R).

**release_month:** The numerical month of release (1-12), important for seasonality.

**is_holiday_release:** A binary flag (1/0) for releasing near major holidays.

**Distributor:** The company responsible for theatrically releasing the film.

**First_Week_Income:** The Target Variable. The sum of the movie's daily box office gross for its first seven days in release.
"""

# --- 5. Final Column Selection and Review ---

# Final list of pre-release features and the target variable
FINAL_PREDICTIVE_COLUMNS = [
    'release_year',
    'budget',
    'runtime',
    'is_sequel',
    'director_name',
    'director_popularity',
    'lead_actor1',
    'lead_actor1_popularity',
    'primary_genre',
    'genre2',
    'studio_1',
    'studio_2',
    'brand_name',
    'mpaa_rating',
    'release_month',
    'is_holiday_release',
    'Distributor',
    'First_Week_Income'
]

# Select the final set of columns, ensuring they exist in the DataFrame
present_columns = [col for col in FINAL_PREDICTIVE_COLUMNS if col in final_dataset.columns]
final_dataset = final_dataset[present_columns]


print("\n--- Final Predictive Dataset (Sample with pre-release features only) ---")
print(final_dataset.head())

# --- Save the final dataset to a new CSV file ---
output_filename = "movie_prediction_dataset_final.csv"
final_dataset.to_csv(output_filename, index=False)

print(f"\nSuccessfully created and saved the final predictive dataset to '{output_filename}'!")